================================================================================
                            PROJECT SUMMARY: Subfloor
================================================================================


--- PROJECT FILE STRUCTURE ---
.
|____index.css
|____context
| |____DataContext.tsx
|____server
| |____lib
| | |____emailService.js
| | |____reportGenerator.js
| | |____reports.js
| | |____scheduler.js
| |____temp-uploads
| |____email-templates
| | |____orderReceived.html
| | |____userInvite.html
| | |____customerReminder.html
| | |____orderDamage.html
| | |____pastDueReminder.html
| |____routes
| | |____notifications.js
| | |____photos.js
| | |____projects.js
| | |____reportGenerator.js
| | |____users.js
| | |____customers.js
| | |____vendors.js
| | |____preferences.js
| | |____messages.js
| | |____products.js
| | |____reports.js
| | |____calendar.js
| | |____search.js
| | |____restore.js
| | |____jobNotes.js
| | |____reminders.js
| | |____installers.js
| | |____orders.js
| | |____events.js
| | |____roles.js
| | |____import.js
| | |____backup.js
| | |____jobs.js
| | |____sampleCheckouts.js
| | |____change-orders.js
| | |____quotes.js
| |____index.js
| |____uploads
| | |____photo-1762749727265-184370968.jpeg etc
| | |____branding
| | | |____logo-1763654366165.png
| | | |____logo-1763829676299.png
| | | |____logo-1763825160367.png
| | | |____logo-1763653815340.png
| | | |____favicon-1763653827118.png
| | | |____logo-1763825080181.png
| | |____avatars
| | | |____avatar-51117396-0980-49c3-a5e2-64624d80bd84-1763561455785-832882225.png
| | |____photo-1763157168801-385337320.jpg
| | |____photo-1763002097382-4328641.jpeg
| |____db.js
| |____package.json
| |____utils.js
| |____node_modules
| |____migrate-profiles.js
| |____tree.txt
| |____make-admin.js
|____backup.bak
|____package-lock.json
|____vite.config.ts
|____userauditplan.txt
|____tsconfig.json
|____App.tsx
|____postcss.config.js
|____services
| |____quoteService.ts
| |____jobNotesService.ts
| |____userService.ts
| |____jobService.ts
| |____customerService.ts
| |____notificationService.ts
| |____projectService.ts
| |____reportService.ts
| |____vendorService.ts
| |____sampleCheckoutService.ts
| |____preferenceService.ts
| |____changeOrderService.ts
| |____materialOrderService.ts
| |____installerService.ts
| |____sampleService.ts
| |____eventService.ts
| |____productService.ts
|____docker-compose.yml
|____Dockerfile
|____caddyfile.old
|____index.js.bak
|____.env
|____temp-uploads
|____.dockerignore
|____.gitignore
|____tailwind.config.js
|____project_1old.txt
|____components
| |____UserManagementSection.tsx
| |____SampleCheckoutsSection.tsx
| |____VariantGeneratorModal.tsx
| |____AddSampleInlineModal.tsx
| |____PricingConfigurationSection.tsx
| |____UserNotificationSettings.tsx
| |____BackupRestoreSection.tsx
| |____FinalizeJobSection.tsx
| |____SampleSelector.tsx
| |____ProductCard.tsx
| |____SampleCarousel.tsx
| |____SystemEmailSettings.tsx
| |____ProductDetailModal.tsx
| |____MentionInput.tsx
| |____ProjectInfoHeader.tsx
| |____ActivityHistory.tsx
| |____ProductForm.tsx
| |____JobNotesSection.tsx
| |____ReceiveOrderModal.tsx
| |____NavigationListener.tsx
| |____OrderCarousel.tsx
| |____BrandingSettingsSection.tsx
| |____MySettingsSection.tsx
| |____import
| | |____ImportReview.tsx
| | |____FileUploader.tsx
| | |____ColumnMapper.tsx
| |____Layout.tsx
| |____RestoreForm.tsx
| |____VariantImageModal.tsx
| |____reports
| | |____InstallerReportTable.tsx
| | |____JobReportTable.tsx
| | |____ReportCharts.tsx
| | |____ProductReportTable.tsx
| |____ModalPortal.tsx
| |____EditInstallerModal.tsx
| |____ChangeOrderSection.tsx
| |____PrintableCheckout.tsx
| |____SampleForm.tsx
| |____QrScanner.tsx
| |____UniversalSearch.tsx
| |____CollapsibleSection.tsx
| |____SampleDetailModal.tsx
| |____MaterialOrdersSection.tsx
| |____UserStatus.tsx
| |____EditChangeOrderModal.tsx
| |____EditProjectModal.tsx
| |____AddEditMaterialOrderModal.tsx
| |____DashboardEmailSettings.tsx
| |____SmartMessage.tsx
| |____QuickCheckoutModal.tsx
| |____AddEditVendorModal.tsx
| |____GlobalProjectSelector.tsx
| |____EditCustomerModal.tsx
| |____QuotesSection.tsx
| |____CustomerCarousel.tsx
| |____CalendarFilter.tsx
| |____SizeManagement.tsx
| |____ProjectCarousel.tsx
| |____ProjectSelector.tsx
| |____CustomerSelector.tsx
|____metadata.json
|____database-backup-2025-11-21T15-07-42-773Z.dump
|____utils
| |____pricingUtils.ts
| |____cryptoUtils.ts
| |____csvUtils.ts
| |____changeFormatter.ts
|____todo.txt
|____package.json
|____Dockerfile.prod
|____schema.sql
|____types.ts
|____Dockerfile.server
|____index.html
|____tree.txt
|____README.md
|____index.tsx
|____pages
| |____CustomerDetail.tsx
| |____InstallerDetail.tsx
| |____CalendarView.tsx
| |____OrderDashboard.tsx
| |____Settings.tsx
| |____SampleLibrary.tsx
| |____CustomerList.tsx
| |____VendorList.tsx
| |____Reports.tsx
| |____Messages.tsx
| |____InstallerList.tsx
| |____Dashboard.tsx
| |____VendorDetail.tsx
| |____ImportData.tsx
| |____ProjectDetail.tsx
| |____QuoteDetail.tsx
|____data
| |____mockData.ts
|____project.txt
|____docker-compose.prod.yml




--- PROJECT OVERVIEW ---

Subfloor is a full-stack web application designed to be a comprehensive management tool for small contracting businesses, such as flooring installers. It provides a single, centralized platform to track the entire lifecycle of a job, from initial customer inquiry to final completion.

The application is built to handle the complex, real-world workflows of a contracting business. Key functionalities include:

  * Customer Relationship Management (CRM): Create, view, and edit a complete list of customers.
  * Project Tracking: Manage individual jobs for each customer, each with its own intelligent status (e.g., New, Quoting, Scheduled, Completed) that updates automatically based on user actions.
  * Sample & Inventory Management: Maintain a central "Sample Library" of materials, and manage a robust multi-step checkout/return process for samples on a per-project basis.
  * Installer & Schedule Management: Manage a list of installers, assign them to jobs via quotes, and view their schedules on a color-coded, interactive calendar to prevent conflicts.
  * Financials: Create, edit, and manage quotes with detailed cost breakdowns. Track change orders, calculate required deposits, and view the final balance due for each job.
  * Material Ordering: Place and track material orders for scheduled jobs.

The entire application is built on a modern, robust technology stack, including a React (TypeScript) frontend, a Node.js (Express) backend API, and a persistent PostgreSQL database. The full stack is containerized with Docker for a stable, portable, and easily reproducible development and deployment environment.


================================================================================
                            DEVELOPMENT HISTORY
================================================================================


--- SESSION 3: Architectural Overhaul & Core Feature Implementation ---
This was a massive session focused on architectural improvements, completing core functionality, and adding major new features.

1. FULL-STACK ARCHITECTURAL OVERHAUL (MAJOR IMPROVEMENT)
    * Backend Refactor: Migrated the entire backend to a clean, router-based architecture in `server/routes/`.
    * Frontend Refactor: Created a dedicated Service Layer (`src/services/`) to separate API logic from state management.
    * Docker Architecture: Corrected `docker-compose.yml` to use a proper multi-service architecture, solving critical networking issues.

2. COMPREHENSIVE "DELETE" FUNCTIONALITY (CORE CRUD COMPLETE)
    * Pattern Established: Built a reusable, safe deletion pattern.
    * Full Implementation: Implemented full-stack delete for Samples, Customers, Projects, and Installers.
    * Advanced Logic: Added business rule enforcement (e.g., preventing deletion of a customer with active projects).

3. "QUICK CHECKOUT" & QR CODE SYSTEM (NEW MAJOR FEATURE)
    * UI/UX: Built a new "Quick Checkout" modal for a fast workflow.
    * Component Architecture: Created reusable `CustomerSelector`, `ProjectSelector`, and `SampleSelector` components.
    * Backend QR Generation: Built a `GET /api/samples/:id/qr` endpoint to generate QR codes for samples.
    * Live QR Scanning: Integrated a camera-based QR code scanner into the checkout flow.

4. FLEXIBLE BUSINESS LOGIC: "INSTALLATION TYPES"
    * Architecture: Implemented "Installation Type" (Managed, Materials Only, etc.) on quotes.
    * Dynamic UI: The Add/Edit Quote modal now intelligently hides irrelevant fields based on the selected type.
    * Decoupled Workflow: Decoupled material ordering from project scheduling for "Materials Only" sales.

5. FULL MOBILE RESPONSIVENESS
    * Main Layout: Refactored `Layout.tsx` to be mobile-first with a collapsible "hamburger" menu.
    * Pages & Grids: Updated all major pages to be responsive and usable on a phone screen.

6. CRITICAL BUG SMASHING & STABILITY
    * Mixed Content: Fixed a persistent "Mixed Content" error by cleaning bad image data.
    * Docker & Networking: Solved multiple `docker-compose` and internal networking errors.
    * Scanner Stability: Fixed a critical bug causing the mobile QR scanner to freeze on a successful scan.

Roadmap (Post-Session 3)
*   Editing: No way to edit a Material Order.
*   Deleting: No way to delete a Material Order.
*   File Uploads: Apply existing system to "Signed Paperwork".
*   "On-the-Fly" Sample Creation: Add during "Quick Checkout" flow.
*   Authentication & Users: The app remains a single-user system.

--------------------------------------------------------------------------------

--- SESSION 4: Backup/Restore System & Docker Hardening ---
This session focused on adding a critical new administrative feature, enhancing existing workflows, and hardening the application's core architecture.

1. FULL-STACK BACKUP & RESTORE SYSTEM (NEW MAJOR FEATURE)
    * New "Settings" Page: Created a dedicated page at `/settings` for administrative functions.
    * Robust Backup: Built backend endpoints (`/api/backup/database`, `/api/backup/images`) that use `pg_dump` to generate reliable ZIP archives.
    * Disaster-Proof Restore: Built backend endpoints to handle uploads for restoring data. Implemented an "atomic swap" strategy for images to avoid file-locking errors.

2. ARCHITECTURAL & DOCKER HARDENING (MAJOR STABILITY IMPROVEMENT)
    * Dedicated Server Dockerfile: Created `Dockerfile.server` to install necessary tools without bloating the frontend image.
    * Eliminated Volume Conflicts: Reconfigured `docker-compose.yml` to use surgical volume mounts for the frontend, preventing Vite's file watcher from locking server files and causing `EBUSY` errors.

3. "EXTEND CHECKOUT" FUNCTIONALITY (NEW FEATURE)
    * Full Stack Implementation: Created a `PATCH` endpoint, service function, and `DataContext` function to allow users to extend a sample's due date by two days.
    * UI Integration: Added a working "Extend" button to the Job Detail page, Sample Detail modal, and Sample Library card view.

4. CRITICAL BUG FIXES & WORKFLOW ENHANCEMENTS
    * Fixed a "Return" button race condition.
    * Fixed the `SampleDetailModal` from closing immediately after returning a sample.

Features We Talked About But Didn't Implement
*   Graceful "Empty State" Handling for when the database is empty.
*   Automatic Pre-Restore Snapshot safety feature.
*   Automated, Scheduled Backups.

--------------------------------------------------------------------------------

--- SESSION 5: Vendor Management System ---
This was a major architectural session focused on building a complete "Vendor Management" system from the ground up and integrating it deeply into core workflows.

1. FULL-STACK VENDOR MANAGEMENT SYSTEM (NEW MAJOR FEATURE)
    * Database: Created a new `vendors` table and refactored the `samples` and `material_orders` tables to use foreign key relationships (`manufacturer_id`, `supplier_id`) instead of free-text fields.
    * Backend API: Built a complete set of RESTful CRUD endpoints for `/api/vendors`.
    * Frontend UI: Created a new "Vendor Directory" page and a reusable "Add/Edit Vendor" modal.

2. DEEP INTEGRATION & WORKFLOW AUTOMATION (MAJOR REFACTOR)
    * "On-the-Fly" Creation: Replaced all manufacturer/supplier text inputs with a consistent, searchable component that allows creating new vendors without leaving the current workflow.
    * Intelligent Autofill & ETA Calculation: The Material Order modal now autofills the supplier and intelligently calculates the material ETA based on the supplier's delivery schedule.

3. CRITICAL BUG SMASHING & REGRESSION FIXES
    * Fixed broken API routes by forcing Docker server rebuilds.
    * Solved database schema mismatch errors by resetting the Docker volume.
    * Fixed modal stacking order (z-index) issues.
    * Fixed a major regression where selecting a manufacturer in the "Add/Edit Sample" modals was failing to save.

--------------------------------------------------------------------------------

--- SESSION 6: Authentication ---
*   A user login system was instituted using Supertokens, transitioning the application from a single-user tool to a multi-user-ready platform.

--------------------------------------------------------------------------------

--- SESSION 7: Full-Stack Stabilization & Critical Workflow Fixes ---
This foundational session focused on identifying and permanently fixing deep-seated issues in the development environment and application state management.

1. FULL-STACK INFRASTRUCTURE STABILIZATION (SOLVED THE RELOAD LOOP)
    * The Problem: The application was caught in a constant page reload loop, making development impossible.
    * The Investigation: Through extensive diagnostic tests, we proved the Docker containers were stable and the reload was triggered by the client-side Vite script due to an unstable WebSocket connection.
    * The Root Cause & Fix: The final root cause was identified as an HTTP protocol mismatch between the Caddy reverse proxy and the Vite dev server. A third party provided a corrected Caddyfile using the `versions h2 h1.1` directive, which stabilized the WebSocket handshake and permanently fixed the reload loop.

2. QUOTE ACCEPTANCE & JOB FINALIZATION WORKFLOW (FULL-STACK BUG FIX)
    * The Problem: Accepting a quote did not correctly transition the project's state, preventing the "Job Details" section from appearing.
    * The Root Cause (Stale State): We diagnosed that the frontend state was inconsistent; the code was updating the local state for the quote, but failing to update the parent project's state.
    * The Full-Stack Solution: We created a new, dedicated workflow (`acceptQuote`) across the entire stack (backend API, service layer, and state management) to ensure both the quote and project are updated transactionally, keeping the UI perfectly in sync with the database. We also fixed a stubborn Vite caching issue by using `docker-compose down -v`.

3. JOB DETAILS & SCHEDULING FORM (UI & API BUG FIXES)
    * The Problem: The "Save Job Details" button was not working correctly, the date fields were not populating, and saving a job with blank dates was crashing the backend API.
    * The Fix: We made the backend `POST /api/jobs` endpoint more robust by sanitizing incoming data (converting empty date strings to NULL). We then fixed the state initialization logic in the `FinalizeJobSection.tsx` component to ensure the form correctly populates with existing job data.

4. UNIFYING UI/UX FOR "ON-THE-FLY" SAMPLE CREATION
    * The Problem: The "Add Sample Inline" modal (in the Quick Checkout flow) was using an outdated UI without the on-the-fly manufacturer search/create functionality.
    * The Fix: We refactored `AddSampleInlineModal.tsx`, replacing its old form with the modern, consistent search component, unifying the user experience.


Session 7

This was a transformative session that took the application from a single-user tool to a secure, multi-user, admin-ready platform. We completed the entire auditing system, fixed several critical bugs, and built the foundational Role-Based Access Control (RBAC) system from the ground up, including a full UI for user and role management.
Phase 1: Foundational Auditing (Completed Pre-Session)

Before this session began, the foundational work for the auditing system had been successfully laid out. A repeatable pattern was established and applied to five core areas of the application: Customers, Projects, Quotes, Installers, and Samples, with preliminary backend work done for Vendors. This involved creating the activity_log table and implementing the necessary backend routes, service functions, and DataContext logic for each.
Phase 2: Auditing Completion, RBAC Implementation & Full-Stack Hardening (This Session)

Our work focused on completing the initial vision and then immediately building the next layer of core infrastructure.

1. AUDITING SYSTEM COMPLETION (NEW MAJOR FEATURE)

    Full-Stack Implementation for Material Orders: We applied the established auditing pattern to the last remaining entity, Material Orders. This was a complex task involving multi-table database transactions on the backend (server/routes/orders.js) and corresponding frontend plumbing (materialOrderService.ts, DataContext.tsx, MaterialOrdersSection.tsx).

    Enhanced Audit Detail UI (MAJOR UX IMPROVEMENT): The generic <ActivityHistory /> component was significantly upgraded. It now intelligently compares the before and after data for any 'UPDATE' action and displays a human-readable, bulleted list of exactly what changed (e.g., "'Phone Number' changed from '555-1111' to '555-2222'"). This functionality was enabled by a new changeFormatter.ts utility.

2. FULL-STACK ROLE-BASED ACCESS CONTROL (RBAC) SYSTEM (NEW MAJOR FEATURE)

    Database Foundation: We created the app_roles and app_user_roles tables in schema.sql to establish a flexible, many-to-many relationship between users and roles.

    Robust Security Middleware: We built a reusable verifyRole middleware function in server/utils.js that can protect any API endpoint, ensuring only users with specified roles (e.g., 'Admin') can access them.

    System-Wide Security Rollout: We systematically applied the verifyRole('Admin') middleware to all sensitive DELETE and user creation endpoints across the entire backend, including for Customers, Projects, Installers, Vendors, Material Orders, and Users.

    Role-Aware Frontend: We integrated the RBAC system into the frontend by fetching the currentUser's roles and using conditional rendering to hide all corresponding "Delete" buttons and the entire User Management UI from non-Admin users.

3. FULL-STACK USER & ROLE MANAGEMENT UI (NEW MAJOR FEATURE)

    Settings Page Redesign: We redesigned the Settings page from a single scrolling page into a clean, scalable tab-based interface ("User Management" and "Backup & Restore").

    Full-Stack Role Management: We built the complete functionality for Admins to manage user roles directly from the UI. This included:

        Backend: New GET /api/roles and PUT /api/users/:userId/roles endpoints.

        Frontend: New service functions and a complete UI overhaul of the UserManagementSection to display users with role checkboxes and "Save" functionality.

        Safeguards: Implemented critical logic to prevent an Admin from deleting themselves or revoking their own Admin status.

4. CRITICAL BUG FIXES & INFRASTRUCTURE HARDENING

    Fixed Critical Rendering Bug: Diagnosed and fixed a React crash that caused a blank page on the SampleDetailModal by correcting a misconfiguration in DataContext.tsx.

    Restored Core Functionality: Fixed the broken QR code feature by restoring the accidentally deleted API route logic in server/routes/samples.js.

    Resolved Fatal SuperTokens Crash (MAJOR STABILITY IMPROVEMENT): Diagnosed a critical startup failure caused by a database table name collision between our custom roles table and SuperTokens' internal tables. We resolved this permanently by renaming our tables to app_roles and app_user_roles.

    Created a Robust Admin Seeding Process: After diagnosing that the initial "first user is admin" logic was flawed, we created a reusable command-line script (server/make-admin.js) to reliably grant Admin privileges, significantly improving the development and deployment workflow.

    Improved Docker Development Workflow: We updated the docker-compose.yml to properly mount the ./server directory as a volume, enabling hot-reloading for the backend and eliminating the need to rebuild the Docker image after every file change.

Status at End of Session

The application is now a feature-complete, secure, and robust multi-user platform. The auditing system provides deep insight into data changes, and the RBAC system ensures that only authorized users can perform sensitive actions. The addition of a complete User and Role Management UI makes the system fully manageable without direct database intervention. The core infrastructure is more stable and the development workflow is significantly improved.

Session 8

1. Customer Creation & Validation Overhaul

We completely rebuilt the customer creation and editing experience to be more flexible and robust.

    Optional & Validated Email: The email field is no longer required, but if a user enters one, they must confirm it, and it's validated for correct formatting.

    Phone Number Validation: Phone numbers are now validated to ensure they contain 10 digits and are auto-formatted for a clean, consistent display.

    Architectural Fix: We resolved a major architectural issue by discovering and removing a separate, hardcoded "Add Customer" form in the CustomerList page, replacing it with our single, reusable, and now fully-validated EditCustomerModal component.

2. "On-the-Fly" Customer Creation in Quick Checkout

We created a seamless workflow for adding new customers directly from the dashboard's "New Checkout" feature.

    Intelligent Search: When a user searches for a customer that doesn't exist, the system now offers to create a new one.

    Pre-populated Data: The "Add New Customer" modal opens with the name the user was searching for already filled in.

    Automatic Selection: After the new customer is created, they are automatically selected in the checkout flow, allowing the user to immediately proceed without having to search again. This was a key UX improvement.

3. Multi-Quote Project & Job Management (Major Feature)

This was the most significant architectural change of the session. We upgraded the application to handle jobs composed of multiple accepted quotes.

    Safe Database Migration: We performed a live database migration to add a quote_id to the change_orders table without any data loss.

    Full-Stack Implementation: We updated the entire application stack—backend API, frontend services, and type definitions—to support this new data relationship.

    UI for Change Orders: Both the "Add" and "Edit" forms for change orders now include a dropdown menu, allowing users to precisely assign a change order to a specific quote.

    Rebuilt Financial Summary: We completely refactored the "Job Details" section. It now displays a clear, itemized financial breakdown for each accepted quote, calculates subtotals, and provides an accurate grand total for the entire job.

    Critical Bug Fixes: We resolved a database crash that occurred when accepting a second quote and fixed a timing bug that was causing new change orders to appear as "Unassigned."

4. Added "Delete Change Order" Functionality

We added the missing ability for administrators to delete change orders.

    Secure Backend Endpoint: A new, admin-only DELETE endpoint with full auditing was created.

    Full Frontend Implementation: We added the necessary functions to the service and data context.

    UI Addition: A "Delete" button, visible only to admins, is now present in the "Edit Change Order" modal, complete with a safety confirmation dialog. We also debugged and fixed a TypeError to make this feature fully functional.

Session 9
Summary of Session 9: UI Enhancements & Major Scheduling Refactor

This session was defined by two main efforts: first, enhancing the user experience on several key pages with dynamic, at-a-glance information; and second, executing a deep, full-stack architectural overhaul of the entire job scheduling system.
1. UI/UX Enhancements & Consistency

We applied the dynamic carousel pattern from the main dashboard to several other pages and added consistent search functionality.

    Customer Dashboard Revamp: The main customer list page (/customers) was significantly upgraded. It now features two carousels at the top, displaying Projects with Samples Out and Projects in the Active Pipeline, providing immediate insight into active work. These carousels intelligently disappear when a user begins searching the main customer list.

    Sample Library "Checked Out" Carousel: The sample library now features a carousel at the top that exclusively shows checked-out samples, sorted by the soonest due date. This makes it easy to see which samples are most urgent.

    Installer Search: A consistent search bar was added to the /installers page, allowing users to quickly filter the list by name or email.

2. Full-Stack Scheduling System Overhaul (Major Feature)

This was the core focus of the session. We rebuilt the application's data model and UI to support more flexible, real-world scheduling needs.

    Database Migration: We performed a live database migration to support the new features without losing any existing data.

        A new job_appointments table was created to allow a single job to have one or more scheduled appointments.

        An is_on_hold boolean column was added to the jobs table.

        The old, rigid scheduled_start_date and scheduled_end_date columns were successfully migrated and removed from the jobs table.

    Full-Stack Implementation: The new data model was integrated across the entire application.

        Backend: The API endpoints for jobs (server/routes/jobs.js) and the calendar (server/routes/calendar.js) were completely rebuilt to read from and write to the new job_appointments table. All updates are now handled transactionally for data integrity.

        Frontend UI: The FinalizeJobSection.tsx component was completely rebuilt. It is no longer a static form but a dynamic interface where users can:

            Add or remove multiple appointment "parts" for a single job.

            Edit the name, dates, and assigned installer for each individual appointment.

            Toggle a job's "On Hold" status with a checkbox.

        Calendar Integration: The calendar now correctly reads the job_appointments array and creates a distinct, color-coded event for every appointment. It also applies a special hashed-out style to any appointments belonging to a job that is marked "On Hold".

3. The Bug We Are Currently Working On (And Just Fixed)

Throughout the refactor, we encountered a series of cascading crashes that were difficult to diagnose.

    The Problem: After the database migration, the application would crash on initial load, and navigating to certain detail pages would also cause a crash. The browser would show a variety of misleading error messages, such as "Failed to fetch customers," "Failed to fetch installers," or "Failed to fetch history."

    What We Tried: We chased these symptoms individually, fixing broken SQL queries in the backend routes for customers.js and installers.js. While these were real bugs, they were not the root cause. We also mistakenly investigated frontend rendering logic in CustomerDetail.tsx and changeFormatter.ts.


Session 10

Session Summary: The Great Sample Refactor & Feature Completion

This session was defined by three major efforts: completing the "Intelligent Sample Data Model" refactor, fixing all the cascading bugs that ensued, and then immediately building two major new features on top of that solid foundation.
1. The Foundational Refactor (Phase 1 Completion)

We completed a massive, full-stack overhaul of the entire sample data model, which had ripple effects across the whole application.

    Database Migration: We executed a complex, multi-step manual database migration. We added a new sample_sizes table, migrated existing size data into it, and dropped the old column, ensuring no data was lost. We also diagnosed and fixed schema inconsistencies in the vendors table that were caused by a faulty backup/restore process.

    Backend Overhaul: We refactored all backend API endpoints related to samples (/api/samples) and search (/api/search) to be fully compatible with the new, structured data model. This included writing new transactional logic for creating/updating samples with multiple sizes.

    System-Wide UI Audit & Repair: We methodically identified and repaired every single component that displayed or searched for sample data. This was the largest part of the effort and included fixing:

        The main "Add/Edit Sample" modals (SampleDetailModal, SampleLibrary).

        The "on-the-fly" add sample modal (AddSampleInlineModal).

        The sample search/selector component (SampleSelector).

        The project-specific checkout list (SampleCheckoutsSection).

        The dashboard and customer page carousels (ProjectCarousel, SampleCarousel).

        The material order creation form (MaterialOrdersSection).

        The global universal search feature.

2. New Feature: Multi-Size "Bubble" Selector

Building directly on our new data model, we implemented a highly-requested feature for handling multiple sample sizes.

    Full-Stack Implementation: We built this feature from the database up, including the new sample_sizes table, updated backend logic to handle arrays of sizes, and a new API endpoint (GET /api/samples/sizes) to serve unique size suggestions.

    Rich UI with react-select: We integrated the react-select library to create a professional "bubble" or "tag" input. This allows users to either select from a list of existing sizes (preventing typos) or create new sizes on the fly.

    Layout Improvements: As requested, we updated the "Add/Edit Sample" form layouts to give the new, more important "Sizes" field its own dedicated row.

3. New Feature: Administrative Size Management

To support the new multi-size feature, we built a complete administrative interface for managing the data.

    Admin-Only API Endpoints: We created new, secure backend routes (PUT and DELETE on /api/samples/sizes) that are protected by our 'Admin' role middleware. These endpoints allow for renaming a size across all samples or safely deleting an unused size.

    New "Data Management" UI: We extended the /settings page with a new "Data Management" tab. Inside, we built a SizeManagement component where administrators can now view all unique sizes in the system, edit them to fix typos, or delete them if they are no longer in use.

4. Major Architectural Improvement: The Reusable SampleForm

In the process of updating the various "add sample" modals, we performed a significant code refactor to improve maintainability.

    DRY Principle ("Don't Repeat Yourself"): We extracted the entire complex sample form logic into its own reusable SampleForm.tsx component.

    Simplified Modals: The main SampleLibrary modal and the AddSampleInlineModal were both gutted of their redundant form code and now simply render the <SampleForm />, making them much cleaner and easier to manage. This ensures a 100% consistent user experience for adding samples anywhere in the app.

Features We Discussed But Did Not Implement

    System-Wide Deletion of a Size from Settings: We built the full UI and backend for this. The only part we intentionally deferred was the logic for what happens when an admin tries to delete a size that is currently in use. The backend correctly blocks this and sends an error, but we haven't built UI to, for example, show the admin which samples are using it or offer to "un-assign and delete."

    "Smart" Size Parsing: We decided to treat each size as a simple, unique text string (e.g., "12x24" is different from "12 x 24"). We did not implement complex logic to parse units or dimensions, instead relying on the autocomplete suggestions to guide users toward consistency.

session 11

SESSION NOTES: Subfloor
Session Summary: Project Dashboard Refactor & "Edit Mode" Implementation

This was a transformative, UI-focused session where we completely overhauled the ProjectDetail page, converting it from a static document into a dynamic, user-customizable dashboard. We then built a full-featured "Edit Mode" with robust, database-backed persistence, and solved several critical bugs related to both the new functionality and existing backend architecture.

1. Full-Stack "Dashboardization" of Project Detail Page (Major Feature)

We rebuilt the project detail page from the ground up to support a flexible grid layout, which involved a full-stack effort.

    Component Refactor: We started by breaking out the "Job Notes" from the monolithic FinalizeJobSection into its own dedicated JobNotesSection component.

    Static Grid Implementation: We replaced the page's linear, multi-column layout with a single, unified 12-column CSS Grid, providing a clean, organized foundation.

    "Card" UI Pattern: We systematically went through every child component (QuotesSection, ActivityHistory, etc.) and applied a consistent "card" styling, making each one a self-contained, modular UI element.

    Backend Hardening (Partial Updates): The new "Save Notes" feature exposed a flaw in our backend. We rebuilt the PATCH /api/jobs endpoint to dynamically handle partial updates, making it far more robust and fixing a critical server crash.

2. Dynamic, User-Customizable Layout System (Major Feature)

Building on the new grid foundation, we implemented a complete drag-and-drop dashboard system.

    Library Integration: We integrated the react-grid-layout library to provide the core functionality.

    Draggable & Resizable Widgets: We added "drag handles" to the header of every card and implemented custom CSS to make the resize grips clearly visible on our dark theme.

    Content Overflow Fix: We solved a persistent bug where content was being cut off by re-architecting every card component to use a flexbox structure with an independently scrollable body (overflow-y-auto), ensuring all content is accessible regardless of the card's size.

3. "Edit Mode" & Global State (Major UX Improvement)

Based on your feedback, we evolved the feature from an "always-on" editable grid to a more intentional and professional "Edit Mode".

    Global State: We added a new global state variable (isLayoutEditMode) and a toggle function (toggleLayoutEditMode) to our central DataContext.

    Centralized Trigger: We integrated the trigger for "Edit Mode" directly into the main UserStatus dropdown menu, making it an application-level setting.

    Conditional UI: The ProjectInfoHeader was rebuilt to be aware of "Edit Mode". It now conditionally displays either the standard project information or a new set of controls: "Save Layout", "Cancel", and "Reset to Default". The ResponsiveGridLayout itself was also modified to be locked or editable based on this global state.

4. Database-Backed Layout Persistence (Major Architectural Improvement)

We graduated the feature from a prototype using localStorage to a production-ready system with full database persistence.

    Database Migration: We created a new user_preferences table in schema.sql with a JSONB column to flexibly store user-specific UI settings.

    New Backend API: We built a new, secure backend route (/api/preferences) with GET and PUT endpoints to fetch and save preferences for the logged-in user.

    Frontend Integration: We created a preferenceService.ts and wired it into the DataContext to fetch preferences on login and save them via a debounced function (to prevent API spam during drag operations). All localStorage logic was successfully removed from the application.

5. Critical Bug Fixes & Architectural Refinements

    Solved "Stuck in Edit Mode" Bug (CRITICAL): We diagnosed and fixed a critical architectural flaw where using useLocation inside our top-level DataContext was causing the app to crash. We solved this by creating a dedicated, headless NavigationListener component placed correctly within the router's context (Layout.tsx) to reliably turn off edit mode upon navigation.

    Eliminated the "Danger Zone" Panel: After a persistent resizing bug with the "Delete Project" panel, we pivoted to a superior architectural solution. We moved the delete functionality to a clean, admin-only button in the ProjectInfoHeader, allowing us to completely remove the problematic panel from the grid and delete the DeleteProjectSection.tsx component, simplifying the entire page.

    Session 12

Today's Accomplishments

    Integrated Material Orders into the Calendar: We started by pulling in Material Order ETAs from the database and displaying them on the calendar with a distinct color, giving you a unified view of both installation schedules and logistics.

    Built a Full-Stack "User Appointment" System: This was the biggest architectural change.

        Database: We successfully performed a live database migration to add new events and event_attendees tables, creating a robust foundation for all future calendar features.

        Backend: We built a brand new, secure CRUD API (/api/events) to create, update, and delete these new appointments from scratch.

        Frontend: We replaced the simple placeholder modal with a full-featured "Add/Edit Appointment" form, complete with fields for time, notes, and a multi-select dropdown for attendees.

    Implemented a Multi-Entity Attendee System: We fulfilled your requirement to invite different types of people to an event. The appointment modal now correctly lists both Users and Installers, allowing you to schedule meetings with anyone in the system.

    Rolled out User-Specific Colors: We built a complete, end-to-end feature for user customization.

        The backend was upgraded to join with user preferences and serve each user's chosen color.

        The Settings page now has a new "My Settings" tab with a working color picker that saves preferences to the database.

        The calendar now uses these colors, dynamically changing an appointment's color based on who the single attendee is, providing instant visual recognition.

    Created a Powerful, Unified Calendar Filter: We refactored the simple installer filter into a comprehensive component that now allows you to filter the calendar view by any combination of Users and Installers, giving you precise control over the schedule you see.

    SESSION 13 SUMMARY

Session Summary: Full-Stack Email Automation, Architectural Refactor & Critical Bug Fixes

This was a massive session focused on building a complete, multi-faceted automated email system from the ground up. The work involved creating new backend infrastructure, building several full-stack features, and then executing a significant architectural refactor to correctly separate system-level and user-level settings. A substantial portion of the session was also dedicated to hunting down and fixing a cascade of critical bugs, culminating in the resolution of a major data integrity issue in the application's user preference system.
1. New Feature: Foundational Email & Scheduling Infrastructure (Backend)

We built the core engine for all current and future email functionality.

    Technology: Integrated Nodemailer for sending emails via Gmail and node-cron for running scheduled tasks.

    Architecture: Created a new server/lib/ directory for backend business logic, housing a reusable emailService.js and a central scheduler.js.

    Configuration: Implemented secure credential management using a root .env file and correctly configured docker-compose.yml with env_file to inject these variables into the server container, solving a critical startup failure.

2. New Feature: Enhanced Internal "Daily Update" Email

We built a complete, user-configurable daily summary email for internal users.

    Initial Implementation: Created the UI for users to opt-in and configure the email's content (Samples Due, Upcoming Jobs, Pending Quotes).

    Feature Enhancement: Based on your feedback, we significantly upgraded the email to also include:

        A new "Jobs in Progress" section.

        A personalized "My Upcoming Appointments" section, which required refactoring the data-gathering functions to be user-specific.

    Testing: Built a "Send Test" button in the UI, allowing users to get immediate feedback on their configuration without waiting for the daily cron job.

3. New Feature: Automated Customer-Facing Reminders

We built two distinct, automated email notifications for customers.

    "Due Tomorrow" Reminder: Created a cron job that runs daily, finds all samples due the next day, and sends a polite reminder email to the corresponding customer.

    "Past Due" Reminder: Implemented your new feature request for an automated "nag" email. This involved:

        Creating a new pastDueReminder.html template.

        Adding a new cron job that finds overdue samples and sends reminders on an adjustable frequency (e.g., every 2 days).

    Admin Controls: Built a "Manual Actions" panel for admins, providing buttons to instantly trigger both the "Due Tomorrow" and "Past Due" reminder emails for all eligible customers, which proved invaluable for testing.

4. Major Architectural Refactor: System vs. User Preferences

We addressed a core design flaw by separating admin-controlled system settings from personal user preferences.

    Database: Created a new system_preferences table via a live migration to act as the single source of truth for all global settings.

    Backend API: Built new, admin-only GET and PUT endpoints at /api/system-preferences to manage these settings.

    UI Split: Restructured the "Settings" page, splitting the monolithic "Notifications" tab into two clear, distinct areas:

        "Email Settings" (Admin Only): A new tab with a SystemEmailSettings.tsx component to control customer-facing emails.

        "My Notifications" (User Facing): A refactored UserNotificationSettings.tsx component focused exclusively on a user's personal daily update preferences.

    Backend Refactor: Updated the scheduler's cron jobs to read their configuration from the correct source: system_preferences for customer emails and user_preferences for the internal daily update.

5. Critical Bug Fixes & Stability Hardening

This session involved extensive and difficult debugging, which ultimately made the entire application more stable.

    Fixed Critical Preference Overwriting Bug (MAJOR STABILITY IMPROVEMENT): Diagnosed and fixed a systemic issue where saving one user preference (e.g., calendar color) would overwrite and delete all others (email settings, project layouts). We solved this by implementing a robust deep-merge strategy within the saveCurrentUserPreferences function in DataContext.tsx, permanently fixing data loss issues across multiple features.

    Solved Multiple Backend Crashes: We identified and fixed several show-stopping bugs that were crashing the server, including a TypeError on getJWTPayload, a fatal typo on toLocaleDateString, and a JavaScript syntax error (catch (error).) in the scheduler.

    Fixed Repetitive SQL Errors: Methodically corrected numerous column does not exist errors in our new queries by cross-referencing the schema.sql file, fixing incorrect names like due_date, checked_in_date, sent_date, and various name columns.

    "Bomb-Proofed" the Sample Name Query: Solved a bug where emails contained blank list items for samples with no style or color. We implemented a robust COALESCE(NULLIF(TRIM(CONCAT_WS(...)))) query to guarantee a descriptive fallback name (Sample ID: X) in all cases.


    SESSION 14: User Identity, Pricing Engine & Advanced Ordering
1. USER IDENTITY & PROFILE SYSTEM (NEW MAJOR FEATURE)

We moved the application beyond simple email-based identity to full user profiles.

    Database: Created a new user_profiles table linked to the authentication system.

    Profile Management:

        Names: Users can now save their First and Last Name.

        Avatars: Implemented a full image upload pipeline for profile pictures (server/uploads/avatars).

        UI: Updated UserStatus (header), Settings, and the Admin User List to display Avatars (or Initials if missing) instead of generic icons.

    Security: Built a secure "Change Password" workflow using the SuperTokens SDK, requiring validation of the current password before allowing changes. (Solved a complex SDK version mismatch issue involving Tenant IDs).

2. THE PRICING ENGINE (NEW MAJOR ARCHITECTURE)

We built a hierarchical pricing system to automatically calculate "Retail Price" from "Unit Cost."

    Global Configuration: Added a new "Pricing Config" tab in Settings (Admin only) to set default Retail Markup, Contractor Markup, and calculation method (Markup vs. Margin).

    Vendor Overrides: Updated the Vendor system to allow specific vendors to override global settings (e.g., "Shaw Floors always gets 60% markup").

    Waterfalls Logic: Created pricingUtils.ts to handle the logic chain: Line Item Override > Variant Override > Vendor Override > Global Default.

3. PRODUCT VARIANTS & PACKAGING (DATA MODEL REFACTOR)

We realized a single price per sample wasn't enough (e.g., Tile comes in 12x24 and Mosaic, with different prices).

    Schema Update: Refactored the sample_sizes table to store rich data (unit_cost, carton_size, uom) instead of just text tags.

    Sample Form: Completely rebuilt SampleForm.tsx with a dynamic "Variant Table," allowing users to define specific costs and packaging for every size available for a product.

    Library View: Updated the card view to calculate and display the Retail Price (e.g., "$5.99 / SF") derived from the cost and markup rules.

4. ADVANCED MATERIAL ORDERING

We overhauled the Material Order form to use this new data to facilitate sales.

    Purchaser Logic: Added a toggle for "Customer vs. Installer", which automatically switches between Retail and Contractor pricing tiers.

    Variant Selection: Added a dropdown to Line Items to select specific sizes (e.g., "12x24"), which auto-fills the correct Unit and Price.

    Carton Calculator: Built a smart utility button that appears when carton_size data is present. It converts "100 SF" into "5 Cartons" with one click, handling the rounding math automatically.

    Snapshots: Updated the database to save a snapshot of the cost/markup at the moment of sale, ensuring historical accuracy even if prices change later.

5. CRITICAL BUG FIXES & STABILITY

    Calendar Colors: Fixed a disconnect between frontend storage and backend queries, allowing users to finally set their own event colors.

    Dashboard Layouts: Fixed a regression where saving a custom layout would collapse widgets. Implemented a "Smart Merge" to preserve widget positions.

    Printouts: Updated the "Sample Checkout" print sheet to include a "Pricing Menu"—a list of all available sizes and their Retail Prices for the checked-out item, giving customers a takeaway menu of options.

Current Status:
The application is now capable of managing the entire sales lifecycle: creating profiles, setting margin goals, defining complex product variants, and generating priced orders with automatic unit conversions.

SESSION 15 SUMMARY: Branding, Theming & UI Architecture

In this session, we successfully transformed Subfloor from a generic, hardcoded application into a fully white-label-ready platform with a dynamic theming engine. We also performed significant architectural cleanup on the Settings page.
1. Full-Stack Branding Engine

We built the infrastructure to allow admins to customize the application's identity without touching code.

    Database: Updated system_preferences to store branding assets and color palettes.

    Backend: Built secure API endpoints (POST/DELETE) using multer to handle Logo and Favicon uploads.

    Frontend: Implemented a dynamic BrandingListener in App.tsx that injects the uploaded Favicon into the browser tab and the Logo into the Sidebar in real-time.

2. Dynamic "Semantic" Theme Engine

We moved the application away from hardcoded Tailwind colors (e.g., bg-blue-600, bg-gray-800) to a semantic variable system.

    CSS Variables: Defined global variables in index.css for primary, secondary, accent, background, surface, and text.

    Tailwind Config: Mapped Tailwind utilities to these CSS variables so the entire app reacts instantly to changes.

    Smart Contrast: Implemented logic to automatically calculate whether text on buttons should be Black or White (text-on-primary) based on the brightness of the user's chosen color.

    Full Light/Dark Mode Control: Users can now fundamentally change the app from Dark Mode to Light Mode by adjusting the "Page Background" and "Surface" colors in Settings.

3. System-Wide UI Refactor (The "Scrub")

We systematically refactored over 30 components to use the new semantic class names, ensuring every modal, button, card, and input respects the user's theme.

    Core Modals: Customer, Project, Installer, Vendor, and Quick Checkout modals.

    Project Detail View: Header, Quotes, Job Notes, Financials, Change Orders, and Material Orders.

    Lists & Libraries: Sample Library, Customer List, Installer List (including removing hardcoded legacy code).

    Navigation: Sidebar, User Status dropdown, and Universal Search.

4. Settings Page Architecture (Refactor)

The Settings.tsx file had grown to over 500 lines and contained multiple distinct features. We performed a major refactor to improve maintainability:

    Component Extraction: Extracted UserManagementSection, BrandingSettingsSection, BackupRestoreSection, and MySettingsSection into their own files.

    Result: Settings.tsx is now a clean layout container that simply manages tabs and renders the appropriate child component.

Current Status

The application is now visually customizable and architecturally cleaner. You have a robust foundation for selling this as a SaaS product or tailoring it to specific clients, with a professional-grade "Theme Editor" built directly into the admin panel.

Here is the detailed summary of Session 16.

This session marked a pivotal transition from "Active Development" to "Production Deployment." We started with UI polish, implemented a major lifecycle feature, and then spent the majority of the time architecting a robust, self-contained production environment.
1. Dashboard & UI Logic Fixes

We refined the dashboard to provide a clearer "at-a-glance" view.

    Fixed "Invalid Date" Bug: Solved a parsing error where ISO date strings were breaking the "Upcoming Deliveries" display. We implemented robust date parsing to handle both SQL and ISO formats safely.

    Consolidated Order Logic: Removed the confusing second order carousel. We standardized on a single "Upcoming Deliveries (Next 5 Days)" view, giving you a focused window into immediate logistics.

2. New Subsystem: "Discontinued Samples"

We built a complete lifecycle management system for inventory that is no longer available but must be kept for historical records.

    Database: Added is_discontinued boolean column to the samples table via a live migration.

    Backend API:

        Updated Search logic to exclude discontinued items from global search.

        Created PATCH /discontinue endpoint to toggle status.

    Frontend UI:

        Library: Added "Active" vs. "Discontinued" tabs to filter the view.

        Detail Modal: Added Admin-only "Discontinue" / "Restore" buttons.

    Guardrails: Updated the SampleSelector and QRScanner to strictly block users from adding discontinued items to new Checkouts or Orders.

3. Infrastructure: The "Production" Build (Major Milestone)

We moved the application from a loose "Dev Mode" (Vite + Node separately) to a hardened "Monolith Container" suitable for real-world deployment.

    Multi-Stage Dockerfile: Created Dockerfile.prod that builds the React frontend and copies the optimized static files into the Node backend, creating a single, lightweight image.

    Full-Stack Server: Modified server/index.js to serve the React static files for any non-API request, eliminating the need for a separate frontend server in production.

    Environment Hardening:

        Implemented a "Trust Proxy" configuration to allow secure cookies behind Caddy.

        Standardized .env variable injection to prevent "Zombie Data" issues.

    Caddy Configuration: Refactored the Caddyfile to remove complex split-routing, pointing all traffic to the single production container.

4. Disaster Recovery & Stability Checks

We rigorously tested the Backup & Restore system in the new environment, uncovering and fixing several critical edge cases.

    Restore Tooling: Updated the Docker image to include postgresql-client so pg_restore actually functions in production.

    "Clean Slate" Restore: Rewrote server/routes/restore.js to use --clean --if-exists flags, ensuring that restoring a backup correctly overwrites existing data without dependency conflicts.

    Schema drift: Manually applied missing migrations to the restored production database to match the latest codebase.

    Bug Fix: Fixed a crash in the DELETE Customer route caused by a missing SQL parameter.

Current Status:
You now have a dual-environment setup. You can code in Dev with hot-reloading, and deploy to Prod with a single Docker command, confident that your data is persistent and secure.



Two sessions missing.



SESSION 19: Intelligence & Collaboration

This session focused on three pillars: Data Ingestion (getting data in), Business Intelligence (getting insights out), and Team Communication (connecting users).
1. The Universal Import Tool (Major Feature)

We solved the "Messy Vendor Data" problem by building a robust, wizard-based Import System.

    Staging & Cleaning: Integrated SheetJS to parse Excel/CSV files client-side. Users can strip "junk rows" (headers/logos) before processing.

    Smart Mapping: Created a ColumnMapper that learns. Users can save "Profiles" (e.g., "Shaw Update") to reuse column mappings. We added "Global Defaults" to fill in missing data (e.g., assigning "Carpet" to all rows).

    Diff Engine: The backend compares incoming data against the live database and generates a "Preview Report" (Green=Update, Blue=New). Users can toggle specific rows to "Skip" or edit names inline before committing the transaction.

2. Business Intelligence Reporting

We transitioned from raw lists to actionable insights.

    Aggregation Engine: Built a raw SQL backend (server/lib/reportGenerator.js) to perform complex financial sums across Projects, Quotes, and Installers.

    Visualizations: Integrated recharts to automatically generate Bar Charts for Revenue Trends and Inventory Counts.

    Interactive Data: Reports aren't just static text; users can click rows to drill down into specific projects or export the entire dataset to CSV.

3. Central Messaging & Notifications (New Subsystem)

We turned the application into a communication hub, reducing the need for external tools like Email or Slack.

    Notification Engine:

        Created a notifications table and a polling system (10s interval).

        Logic: When a Job Note is posted, the Project Manager and all thread participants receive an alert.

        UI: Added a "Red Dot" badge to the User Avatar and a dropdown list of unread events.

        Smart Clearing: Visiting a Project page or a Chat conversation automatically marks relevant notifications as "Read".

    Direct Messaging:

        Built a full-page Chat Interface (/messages) for private user-to-user conversations.

        Includes a sidebar with unread counts and last-active timestamps.

4. "Smart Text" System (ERP Workflow)

We implemented a GitHub-style "Mention" system to link data records within conversations.

    The Input: A custom MentionInput component that triggers search dropdowns on specific keystrokes:

        @ for Users

        ! for Projects

        # for Products

        \ for Customers

        + for Installers

    The Renderer: A SmartMessage component that parses these tags (stored as @[type:id|label]) and renders them as clickable, color-coded links that navigate directly to the relevant record.

5. Architectural Improvements

    Project Assignment: Added manager_id to Projects, allowing users to assign a "Project Lead".

    Inventory 2.0 Polish: Restored Packaging Data (carton_size, uom) to the edit forms and import logic.

    React Portals: Solved a critical UI bug where modals were trapped inside dashboard widgets by rendering them at the document root.

    Sample Selection: Added a "Design Board" workflow where checked-out samples can be flagged as "Selected" and immediately converted into a Material Order.

Here is the summary of Session 20 (Performance & Architecture Overhaul).

Primary Goal: To modernize the data layer and optimize the application for scale.
1. React Query Migration (The "Engine Swap")

    The Change: We moved away from the monolithic DataContext state management to TanStack Query.

    The Benefit:

        Isolation: Updating "Projects" no longer forces "Customers" to re-render.

        Caching: Data persists between page navigations (instant loads).

        Stability: Removed complex useEffect chains and manual polling logic.

    Execution: Created 10+ custom hooks (useProducts, useProjects, useMaterialOrders, etc.) and refactored every major page (Dashboard, SampleLibrary, ProjectDetail) to use them.

2. High-Performance Virtualization (The "DOM Killer")

    The Change: Implemented @tanstack/react-virtual for the Sample Library and Import Preview.

    The Benefit: The browser now renders only ~20 items at a time, even if the list has 5,000 items. Scrolling is buttery smooth and memory usage is minimal.

    Grid Logic: Built a custom useGridColumns hook to handle responsive virtualization (calculating rows vs columns dynamically).

3. Image Optimization Pipeline (The "Bandwidth Saver")

    The Change: Installed sharp (native image processor) on the backend.

    The Logic: When an image is uploaded:

        Save Original (High Res).

        Generate Thumbnail (300px JPEG).

        Save both paths to DB.

    Migration: Wrote and ran a script to process 29 existing products, moving files into a clean uploads/products/ folder structure.

    Result: The Sample Library now loads ~95% less data.

4. The "Job Binder" (Project Files)

    The Feature: Built a dual-mode Files Widget for projects.

        Photos Tab: Visual grid for site photos.

        Documents Tab: List view for PDFs/Contracts.

    Integration: Updated the Receive Order modal to allow uploading Packing Slips directly into this binder.

5. Rebranding ("Project Subfloor")

    Identity: Renamed the app from "Joblogger" to "Subfloor" in configuration and UI.

    White-Labeling: Added a Company Name setting in the DB. Updated all email templates to dynamically inject this name and the company logo.

Session 20 missing

Session 21

Now have the ability to deploy via Git Hub.